#!/bin/bash

# niri-launch-tui: Launch a TUI application in a terminal with a specific app-id
# Usage: niri-launch-tui [--app-id ID] [--hold] <command> [args...]
#
# Options:
#   --app-id ID   Set the window app-id for Niri window rules
#   --hold        Keep terminal open after command exits (wait for keypress)

# Parse arguments
APP_ID=""
HOLD=false
POSITIONAL=()
while [[ $# -gt 0 ]]; do
  case $1 in
    --app-id)
      shift
      APP_ID="$1"
      shift
      ;;
    --hold)
      HOLD=true
      shift
      ;;
    *)
      POSITIONAL+=("$1")
      shift
      ;;
  esac
done
set -- "${POSITIONAL[@]}"

# Need at least a command
if [[ $# -eq 0 ]]; then
    echo "Usage: niri-launch-tui [--app-id ID] [--hold] <command> [args...]" >&2
    exit 1
fi

# Build the command string
CMD="$1"
shift

if [[ -z "$APP_ID" ]]; then
    APP_NAME=$(basename "$CMD")
    APP_ID="org.niri.$APP_NAME"
fi

# If --hold is set, wrap command to wait for keypress
# Also auto-detect one-shot commands (not interactive TUIs)
if [[ "$HOLD" == "true" ]]; then
    # Wrap in bash to show output and wait
    FULL_CMD="$CMD $*; echo ''; echo 'Press any key to close...'; read -n1 -s"
else
    FULL_CMD="$CMD $*"
fi

# Check for available terminal and launch
# Use bash -ic (interactive) to enable colors and source user's bashrc
if command -v alacritty >/dev/null; then
    exec setsid alacritty --class="$APP_ID" -e bash -ic "$FULL_CMD" &>/dev/null &
elif command -v foot >/dev/null; then
    exec setsid foot -a "$APP_ID" bash -ic "$FULL_CMD" &>/dev/null &
elif command -v kitty >/dev/null; then
    exec setsid kitty --class="$APP_ID" bash -ic "$FULL_CMD" &>/dev/null &
elif command -v ghostty >/dev/null; then
    exec setsid ghostty --class="$APP_ID" -e bash -ic "$FULL_CMD" &>/dev/null &
elif command -v xdg-terminal-exec >/dev/null; then
    exec setsid xdg-terminal-exec --app-id="$APP_ID" -e bash -ic "$FULL_CMD" &>/dev/null &
else
    echo "No suitable terminal found." >&2
    exit 1
fi
